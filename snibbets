#!/usr/bin/env ruby
# Snibbets 2.0.0

require 'optparse'
require 'readline'
require 'json'
require 'cgi'
require 'shellwords'
require 'yaml'
require 'fileutils'


module TTY
  # stolen from https://github.com/piotrmurach/tty-which/blob/master/lib/tty/which.rb
  # MIT License
  module Which
    # Find an executable in a platform independent way
    def which(cmd, paths: search_paths)
      if file_with_path?(cmd)
        return cmd if executable_file?(cmd)

        extensions.each do |ext|
          exe = "#{cmd}#{ext}"
          return ::File.absolute_path(exe) if executable_file?(exe)
        end
        return nil
      end

      paths.each do |path|
        if file_with_exec_ext?(cmd)
          exe = ::File.join(path, cmd)
          return ::File.absolute_path(exe) if executable_file?(exe)
        end
        extensions.each do |ext|
          exe = ::File.join(path, "#{cmd}#{ext}")
          return ::File.absolute_path(exe) if executable_file?(exe)
        end
      end
      nil
    end
    module_function :which

    def app_bundle(cmd)
      app = cmd.sub(/(\.app)?$/, '.app')
      cmd.sub!(/\.app$/, '')
      app_dirs = %w[/Applications /Applications/Setapp ~/Applications]
      return cmd if ::File.exist?(app)

      return cmd if app_dirs.any? { |dir| ::File.exist?(::File.join(dir, app)) }

      false
    end
    module_function :app_bundle

    def bundle_id?(cmd)
      cmd =~ /^\w+(\.\w+){2,}/
    end
    module_function :bundle_id?

    def app?(cmd)
      if file_with_path?(cmd)
        return cmd if app_bundle(cmd)
      else
        app = app_bundle(cmd)
        return app if app
      end

      false
    end
    module_function :app?

    # Check if executable exists in the path
    def exist?(cmd, paths: search_paths)
      !which(cmd, paths: paths).nil?
    end
    module_function :exist?

    # Find default system paths
    def search_paths(path = ENV["PATH"])
      paths = if path && !path.empty?
                path.split(::File::PATH_SEPARATOR)
              else
                %w[/usr/local/bin /usr/ucb /usr/bin /bin]
              end
      paths.select(&Dir.method(:exist?))
    end
    module_function :search_paths

    # All possible file extensions
    def extensions(path_ext = ENV["PATHEXT"])
      return [""] unless path_ext

      path_ext.split(::File::PATH_SEPARATOR).select { |part| part.include?(".") }
    end
    module_function :extensions

    # Determines if filename is an executable file
    def executable_file?(filename, dir = nil)
      path = ::File.join(dir, filename) if dir
      path ||= filename
      ::File.file?(path) && ::File.executable?(path)
    end
    module_function :executable_file?

    # Check if command itself has executable extension
    def file_with_exec_ext?(filename)
      extension = ::File.extname(filename)
      return false if extension.empty?

      extensions.any? { |ext| extension.casecmp(ext).zero? }
    end
    module_function :file_with_exec_ext?

    # Check if executable file is part of absolute/relative path
    def file_with_path?(cmd)
      ::File.expand_path(cmd) == cmd
    end
    module_function :file_with_path?
  end # Which
end # TTY

class String
  def remove_spotlight_tags
    words = Shellwords.shellsplit(self)
    words.delete_if do |word|
      word =~ /^\w+:/
    end

    words.join(' ').strip
  end

  def remove_spotlight_tags!
    replace remove_spotlight_tags
  end

  def remove_meta
    input = dup
    lines = input.split(/\n/)
    while true
      line = lines.shift
      if line =~ /^\s*[A-Z\s]+\w:\s*\S+/i || line =~ /^-{3,}\s*$/
        next
      end
      break
    end
    lines.join("\n")
  end

  # Are there multiple snippets (indicated by ATX headers)
  def multiple?
    gsub(/(`{3,}).*?\n\1/m, '').scan(/^#+/).length > 1
  end

  # Is the snippet in this block fenced?
  def fenced?
    count = scan(/^```/).length
    count > 1 && count.even?
  end

  def indented?
    self =~ /^( {4,}|\t+)/
  end

  def rx
    ".*#{gsub(/\s+/, '.*')}.*"
  end

  # remove outside comments, fences, and indentation
  def clean_code
    block = dup

    # if it's a fenced code block, just discard the fence and everything
    # outside it
    if block.fenced?
      code_blocks = block.scan(/(`{3,})(\w+)?\s*\n(.*?)\n\1/m)
      code_blocks.map! { |b| b[2].strip }
      return code_blocks.join("\n\n")
    end

    # assume it's indented code, discard non-indented lines and outdent
    # the rest
    block = block.outdent if block.indented?

    block
  end

  def outdent
    lines = split(/\n/)

    incode = false
    code = []
    lines.each do |line|
      next if line =~ /^\s*$/ && !incode

      incode = true
      code.push(line)
    end

    return self unless code[0]

    indent = code[0].match(/^( {4,}|\t+)(?=\S)/)

    if indent
      code.map! { |line| line.sub(/(?mi)^#{indent[1]}/, '') }.join("\n")
    else
      self
    end
  end

  # Returns an array of snippets. Single snippets are returned without a
  # title, multiple snippets get titles from header lines
  def snippets
    content = dup.remove_meta
    # If there's only one snippet, just clean it and return
    return [{ 'title' => '', 'code' => content.clean_code.strip }] unless multiple?

    # Split content by ATX headers. Everything on the line after the #
    # becomes the title, code is gleaned from text between that and the
    # next ATX header (or end)
    sections = []
    counter = 0
    code_blocks = {}

    sans_blocks = content.gsub(/^(`{3,})(\w+)?\s*\n(.*?)\n\1/m) do
      counter += 1
      code_blocks["block#{counter}"] = Regexp.last_match(3)
      "<block#{counter}>\n"
    end

    sans_blocks = sans_blocks.gsub(/(?mi)^((?:\s{4,}|\t+)\S[\s\S]*?)\n(?=\S|$)/) do
      counter += 1
      code = Regexp.last_match(1).split(/\n/)
      code.shift

      code_blocks["block#{counter}"] = code.join("\n").outdent

      "<block#{counter}>\n"
    end

    content = []
    if sans_blocks =~ /<block\d+>/
      sans_blocks.each_line do |line|
        if line =~ /^#/ || line =~ /<block\d+>/
          content << line
        end
      end

      parts = content.join("\n").split(/^#+/)
    else
      parts = sans_blocks.gsub(/\n{2,}/, "\n\n").split(/^#+/)
    end

    parts.shift

    parts.each do |p|
      lines = p.split(/\n/)

      title = lines.shift.strip.sub(/[.:]$/, '')
      block = lines.join("\n").gsub(/<(block\d+)>/) { code_blocks[Regexp.last_match(1)] }

      code = block.clean_code

      next unless code && !code.empty?

      sections << {
        'title' => title,
        'code' => code
      }
    end
    return sections
  end
end

def find_query_in_options(filename, res, query)
  options = res.map { |m| "#{filename} #{m['title']}" }
  words = query.split(/ +/)
  words.delete_if { |word| options.none? { |o| o =~ /#{word}/i } }
  words.map { |w| w.downcase }.join(' ')
end

def remove_items_without_query(filename, res, query)
  q = find_query_in_options(filename, res, query).split(/ /)
  res.delete_if do |opt|
    !q.any? do |word|
      "#{filename} #{opt['title']}" =~ /#{word}/i
    end
  end
  res
end

def gum_menu(executable, res, title, query, filename)
  unless query.nil? || query.empty?
    res = remove_items_without_query(filename, res, query)
    return res[0] if res.count == 1
  end

  if res.count == 0
    warn 'No matches found'
    Process.exit 1
  end

  options = res.map { |m| m['title'] }
  q = query.nil? ? '' : find_query_in_options(filename, res, query)
  puts title
  selection = `echo #{Shellwords.escape(options.join("\n"))} | #{executable} filter --height=#{options.count}`.strip
  Process.exit 1 if selection.empty?

  res.select { |m| m['title'] =~ /#{Regexp.escape(selection)}/ }[0]
end

def fzf_menu(executable, res, title, query, filename)
  orig_options = res.dup
  unless query.nil? || query.empty?
    res = remove_items_without_query(filename, res, query)
    return res[0] if res.count == 1
  end

  if res.count == 0
    res = orig_options
  end

  options = res.map { |m| "#{filename}: #{m['title']}" }
  q = query.nil? ? '' : find_query_in_options(filename, res, query)
  args = [
    "--height=#{options.count + 2}",
    %(--prompt="#{title} > "),
    '-1',
    %(--header="#{filename}"),
    # '--header-first',
    '--reverse',
    '--no-info',
    %(--query="#{q}"),
    '--tac'
  ]
  selection = `echo #{Shellwords.escape(options.join("\n"))} | #{executable} #{args.join(' ')}`.strip
  Process.exit 1 if selection.empty?

  result = res.select { |m|
    m['title'] == selection.sub(/^.*?: /, '')
  }

  result[0]
end

# Generate a numbered menu, items passed must have a title property
def console_menu(res, title, filename, query: nil)
  unless query.nil? || query.empty?
    res = remove_items_without_query(filename, res, query)
    return res[0] if res.count == 1
  end

  if res.count == 0
    warn 'No matches found'
    Process.exit 1
  end

  stty_save = `stty -g`.chomp

  trap('INT') do
    system('stty', stty_save)
    Process.exit 1
  end

  # Generate a numbered menu, items passed must have a title property('INT') { system('stty', stty_save); exit }
  counter = 1
  $stderr.puts
  res.each do |m|
    $stderr.printf("%<counter>2d) %<title>s\n", counter: counter, title: m['title'])
    counter += 1
  end
  $stderr.puts

  begin
    $stderr.printf(title.sub(/:?$/, ': '), res.length)
    while (line = Readline.readline('', true))
      unless line =~ /^[0-9]/
        system('stty', stty_save) # Restore
        exit
      end
      line = line.to_i
      return res[line - 1] if line.positive? && line <= res.length

      warn 'Out of range'
      console_menu(res, title)
    end
  rescue Interrupt
    system('stty', stty_save)
    exit
  end
end

def menu(res, filename: nil, title: 'Select one', query: nil, options: {})
  query.remove_spotlight_tags! unless query.nil?
  fzf = TTY::Which.which('fzf')
  return fzf_menu(fzf, res, title, query, filename) unless fzf.empty?

  gum = TTY::Which.which('gum')
  return gum_menu(gum, res, title, query, filename) unless gum.empty?

  console_menu(res, title, filename, query: query)
end

# Search the snippets directory for query using find and grep
def search(query, folder, matches: [], try: 0, options: {})
  # start by doing a spotlight search, if that fails, start trying:
  # First try only search by filenames
  # Second try search with grep
  ext = options[:extension] || 'md'
  cmd = case try
        when 1
          %(find "#{folder}" -iregex '#{query.rx}' -name '*.#{ext}')
        when 2
          rg = TTY::Which.which('rg')
          ag = TTY::Which.which('ag')
          ack = TTY::Which.which('ack')
          if options[:name_only]
            nil
          elsif !rg.empty?
            %(#{rg} -li --color=never --glob='*.#{ext}' '#{query.rx}' "#{folder}")
          elsif !ag.empty?
            %(#{ag} -li --nocolor -G '.*.#{ext}' '#{query.rx}' "#{folder}")
          elsif !ack.empty?
            %(#{ack} -li --nocolor --markdown '#{query.rx}' "#{folder}")
          else
            %(grep -iEl '#{query.rx}' "#{folder}"/**/*.#{ext})
          end
        else
          mdfind = TTY::Which.which('mdfind')
          if mdfind.empty?
            nil
          else
            name_only = options[:name_only] ? '-name ' : ''
            %(mdfind -onlyin #{folder} #{name_only}'#{query} filename:.#{ext}' 2>/dev/null)
          end
        end

  res = cmd.nil? ? '' : `#{cmd}`.strip

  results = []

  unless res.empty?
    lines = res.split(/\n/)
    lines.each do |l|
      results << {
        'title' => File.basename(l, '.*'),
        'path' => l
      }
    end

    matches.concat(results).sort_by! { |a| a['title'] }.uniq!

    return matches unless matches.empty?
  end

  return matches if try == 2

  # if no results on the first try, try again searching all text
  search(query, folder, matches: matches, try: try + 1, options: options) if matches.empty?
end

def highlight_pygments(executable, code, syntax, theme)
  syntax = syntax.empty? ? '-g' : "-l #{syntax}"
  `echo #{Shellwords.escape(code)} | #{executable} #{syntax}`
end

def highlight_skylight(executable, code, syntax, theme)
  return code if syntax.empty?

  `echo #{Shellwords.escape(code)} | #{executable} --syntax #{syntax}`
end

def highlight(code, filename, theme = 'monokai')
  syntax = syntax_from_extension(filename)

  skylight = TTY::Which.which('skylighting')
  return highlight_skylight(skylight, code, syntax, theme) unless skylight.empty?

  pygments = TTY::Which.which('pygmentize')
  return highlight_pygments(pygments, code, syntax, theme) unless pygments.empty?

  code
end

def ext_to_lang(ext)
  case ext
  when /^(as|applescript|scpt)$/
    'applescript'
  when /^m$/
    'objective-c'
  when /^(pl|perl)$/
    'perl'
  when /^py$/
    'python'
  when /^(js|jq(uery)?|jxa)$/
    'javascript'
  when /^rb$/
    'ruby'
  when /^cc$/
    'c'
  when /^(ba|fi|z|c)?sh$/
    'bash'
  when /^pl$/
    'perl'
  else
    if %w[awk sed css sass scss less cpp php c sh swift html erb json xpath sql htaccess].include?(ext)
      ext
    else
      ''
    end
  end
end

def syntax_from_extension(filename)
  ext_to_lang(filename.split(/\./)[1])
end

def best_editor
  if ENV['EDITOR']
    ENV['EDITOR']
  elsif ENV['GIT_EDITOR']
    ENV['GIT_EDITOR']
  else
    return TTY::Which.which('code') if TTY::Which.exist?('code')

    return TTY::Which.which('subl') if TTY::Which.exist?('subl')

    return TTY::Which.which('bbedit') if TTY::Which.exist?('bbedit')

    return TTY::Which.which('nano') if TTY::Which.exist?('nano')

    return TTY::Which.which('vim') if TTY::Which.exist?('vim')

    return 'TextEdit'
  end
end

def open_snippet_in_editor(filepath, options)
  editor = options[:editor] || best_editor

  if editor.nil?
    `open "#{filepath}"`
  elsif editor =~ /^TextEdit/
    `open -a TextEdit "#{filepath}"`
  elsif TTY::Which.bundle_id?(editor)
    `open -b "#{editor}" "#{filepath}"`
  elsif TTY::Which.app?(editor)
    `open -a "#{editor}" "#{filepath}"`
  else
    if TTY::Which.exist?(editor)
      editor = TTY::Which.which(editor)
      system %(#{editor} "#{filepath}") if editor
    end
  end
end

def config_dir
  File.expand_path('~/.config/snibbets')
end

def config_file
  File.join(config_dir, 'snibbets.yml')
end

def read_config
  if File.exist?(config_file)
    YAML.load(IO.read(config_file))
  else
    {}
  end
end

def write_config(options)
  raise 'Error creating config directory, file exists' if File.exist?(config_dir) && !File.directory?(config_dir)

  FileUtils.mkdir_p(config_dir) unless File.directory?(config_dir)
  File.open(config_file, 'w') { |f| f.puts(YAML.dump(options)) }
end

DEFAULT_OPTIONS = {
  all: false,
  editor: best_editor,
  extension: 'md',
  highlight: false,
  interactive: true,
  launchbar: false,
  name_only: false,
  output: 'raw',
  source: File.expand_path('~/Dropbox/Snippets')
}.freeze

custom_config = read_config
options = DEFAULT_OPTIONS.merge(custom_config)
write_config(options) unless options.equal?(custom_config)

save_config = false
edit_config = false
edit_snippet = false

optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [options] query"

  opts.on('-a', '--all', 'If a file contains multiple snippets, output all of them (no menu)') do
    options[:all] = true
  end

  opts.on('-e', '--edit', 'Open the selected snippet in your configured editor') do
    edit_snippet = true
  end


  opts.on('-n', '--name-only', 'Only search file names, not content') do
    options[:name_only] = true
  end

  opts.on('-o', '--output FORMAT', 'Output format (json|launchbar|raw)') do |outformat|
    valid = %w[json launchbar lb raw]
    if outformat.downcase =~ /(launchbar|lb)/
      options[:launchbar] = true
      options[:interactive] = false
    elsif valid.include?(outformat.downcase)
      options[:output] = outformat.downcase
    end
  end

  opts.on('-q', '--quiet', 'Skip menus and display first match') do
    options[:interactive] = false
    options[:launchbar] = false
  end

  opts.on('-s', '--source FOLDER', 'Snippets folder to search') do |folder|
    options[:source] = File.expand_path(folder)
  end

  opts.on('--configure', 'Open the configuration file in your default editor') do
    edit_config = true
  end

  opts.on('--highlight', 'Use pygments or skylighting to syntax highlight (if installed)') do
    options[:highlight] = true
  end

  opts.on('--save', 'Save the current command line options to the YAML configuration') do
    save_config = true
  end

  opts.on('-h', '--help', 'Display this screen') do
    puts optparse
    Process.exit 0
  end
end

optparse.parse!

if save_config
  write_config(options)
  puts "Configuration saved to #{config_file}"
end

if edit_config
  write_config(options)
  editor = options[:editor]
  if editor.nil?
    `open "#{config_file}"`
  else
    `#{editor} "#{config_file}"`
  end
  Process.exit 0
end

unless File.directory?(options[:source])
  puts "The Snippets folder doesn't exist, please configure it."
  puts "Run `snibbets --configure` to open the config file for editing."
  Process.exit 1
end

query = ''

if options[:launchbar]
  query = if $stdin.stat.size.positive?
            $stdin.read.force_encoding('utf-8')
          else
            ARGV.join(' ')
          end
elsif ARGV.length
  query = ARGV.join(' ')
end

query = CGI.unescape(query)

if query.strip.empty?
  if save_config
    Process.exit 0
  else
    puts 'No search query'
    puts optparse
    Process.exit 1
  end
end

results = search(query, options[:source], matches: [], try: 0, options: options)

if options[:launchbar]
  output = []

  if results.empty?
    out = {
      'title' => 'No matching snippets found'
    }.to_json
    puts out
    Process.exit
  end

  results.each do |result|
    input = IO.read(result['path'])
    snippets = input.snippets
    next if snippets.empty?

    children = []

    if snippets.length == 1
      output << {
        'title' => result['title'],
        'path' => result['path'],
        'action' => 'copyIt',
        'actionArgument' => snippets[0]['code'],
        'label' => 'Copy'
      }
      next
    end

    snippets.each { |s|
      children << {
        'title' => s['title'],
        'path' => result['path'],
        'action' => 'copyIt',
        'actionArgument' => s['code'],
        'label' => 'Copy'
      }
    }

    output << {
      'title' => result['title'],
      'path' => result['path'],
      'children' => children
    }
  end

  puts output.to_json
else
  filepath = nil
  if results.empty?
    warn 'No results'
    Process.exit 0
  elsif results.length == 1 || !options[:interactive]
    filepath = results[0]['path']
    input = IO.read(filepath)
  else
    answer = menu(results, title: 'Select a file', options: options)
    filepath = answer['path']
    input = IO.read(filepath)
  end

  if edit_snippet
    open_snippet_in_editor(filepath, options)
    Process.exit 0
  end

  snippets = input.snippets

  if snippets.empty?
    warn 'No snippets found'
    Process.exit 0
  elsif snippets.length == 1 || !options[:interactive]
    if options[:output] == 'json'
      $stdout.puts snippets.to_json
    else
      snippets.each do |snip|
        header = File.basename(filepath, '.md')
        warn header
        warn '-' * header.length
        code = snip['code']
        code = highlight(code, filepath) if options[:highlight]
        $stdout.puts code
      end
    end
  elsif snippets.length > 1
    if options[:all]
      if options[:output] == 'json'
        $stdout.puts snippets.to_json
      else
        snippets.each do |snippet|
          $stdout.puts snippet['title']
          $stdout.puts '-' * snippet['title'].length
          $stdout.puts snippet['code']
          $stdout.puts
        end
      end
    else
      snippets.push({ 'title' => 'All snippets', 'code' => '' })

      answer = menu(snippets, filename: File.basename(filepath, '.md'), title: 'Select snippet', query: query, options: options)

      if answer['title'] == 'All snippets'
        snippets.delete_if { |s| s['title'] == 'All snippets'}
        if options[:output] == 'json'
          $stdout.puts snippets.to_json
        else
          header = File.basename(filepath, '.md')
          warn header
          warn '=' * header.length
          snippets.each do |snippet|
            $stdout.puts snippet['title']
            $stdout.puts '-' * snippet['title'].length
            $stdout.puts snippet['code']
            $stdout.puts
          end
        end
      elsif options[:output] == 'json'
        $stdout.puts answer.to_json
      else
        header = "#{File.basename(filepath, '.md')}: #{answer['title']}"
        warn header
        warn '-' * header.length
        code = answer['code']
        code = highlight(code, filepath) if options[:highlight]
        $stdout.puts code
      end
    end
  end
end
