#!/usr/bin/env ruby
VERSION = '2.0.1'

require 'optparse'
require 'readline'
require 'json'
require 'cgi'
require 'shellwords'
require 'yaml'
require 'fileutils'


module TTY
  # stolen from https://github.com/piotrmurach/tty-which/blob/master/lib/tty/which.rb
  # MIT License
  module Which
    # Find an executable in a platform independent way
    def which(cmd, paths: search_paths)
      if file_with_path?(cmd)
        return cmd if executable_file?(cmd)

        extensions.each do |ext|
          exe = "#{cmd}#{ext}"
          return ::File.absolute_path(exe) if executable_file?(exe)
        end
        return nil
      end

      paths.each do |path|
        if file_with_exec_ext?(cmd)
          exe = ::File.join(path, cmd)
          return ::File.absolute_path(exe) if executable_file?(exe)
        end
        extensions.each do |ext|
          exe = ::File.join(path, "#{cmd}#{ext}")
          return ::File.absolute_path(exe) if executable_file?(exe)
        end
      end
      nil
    end
    module_function :which

    def app_bundle(cmd)
      app = cmd.sub(/(\.app)?$/, '.app')
      cmd.sub!(/\.app$/, '')
      app_dirs = %w[/Applications /Applications/Setapp ~/Applications]
      return cmd if ::File.exist?(app)

      return cmd if app_dirs.any? { |dir| ::File.exist?(::File.join(dir, app)) }

      false
    end
    module_function :app_bundle

    def bundle_id?(cmd)
      cmd =~ /^\w+(\.\w+){2,}/
    end
    module_function :bundle_id?

    def app?(cmd)
      if file_with_path?(cmd)
        return cmd if app_bundle(cmd)
      else
        app = app_bundle(cmd)
        return app if app
      end

      false
    end
    module_function :app?

    # Check if executable exists in the path
    def exist?(cmd, paths: search_paths)
      !which(cmd, paths: paths).nil?
    end
    module_function :exist?

    # Find default system paths
    def search_paths(path = ENV["PATH"])
      paths = if path && !path.empty?
                path.split(::File::PATH_SEPARATOR)
              else
                %w[/usr/local/bin /usr/ucb /usr/bin /bin]
              end
      paths.select(&Dir.method(:exist?))
    end
    module_function :search_paths

    # All possible file extensions
    def extensions(path_ext = ENV["PATHEXT"])
      return [""] unless path_ext

      path_ext.split(::File::PATH_SEPARATOR).select { |part| part.include?(".") }
    end
    module_function :extensions

    # Determines if filename is an executable file
    def executable_file?(filename, dir = nil)
      path = ::File.join(dir, filename) if dir
      path ||= filename
      ::File.file?(path) && ::File.executable?(path)
    end
    module_function :executable_file?

    # Check if command itself has executable extension
    def file_with_exec_ext?(filename)
      extension = ::File.extname(filename)
      return false if extension.empty?

      extensions.any? { |ext| extension.casecmp(ext).zero? }
    end
    module_function :file_with_exec_ext?

    # Check if executable file is part of absolute/relative path
    def file_with_path?(cmd)
      ::File.expand_path(cmd) == cmd
    end
    module_function :file_with_path?
  end # Which
end # TTY

class String
  def remove_spotlight_tags
    words = Shellwords.shellsplit(self)
    words.delete_if do |word|
      word =~ /^\w+:/
    end

    words.join(' ').strip
  end

  def remove_spotlight_tags!
    replace remove_spotlight_tags
  end

  def remove_meta
    input = dup
    lines = input.split(/\n/)
    while true
      line = lines.shift
      if line =~ /^\s*[A-Z\s]+\w:\s*\S+/i || line =~ /^-{3,}\s*$/
        next
      end
      break
    end
    lines.join("\n")
  end

  # Are there multiple snippets (indicated by ATX headers)
  def multiple?
    gsub(/(`{3,}).*?\n\1/m, '').scan(/^#+/).length > 1
  end

  # Is the snippet in this block fenced?
  def fenced?
    count = scan(/^```/).length
    count > 1 && count.even?
  end

  def indented?
    self =~ /^( {4,}|\t+)/
  end

  def rx
    ".*#{gsub(/\s+/, '.*')}.*"
  end

  # remove outside comments, fences, and indentation
  def clean_code
    block = dup

    # if it's a fenced code block, just discard the fence and everything
    # outside it
    if block.fenced?
      code_blocks = block.scan(/(`{3,})(\w+)?\s*\n(.*?)\n\1/m)
      code_blocks.map! { |b| b[2].strip }
      return code_blocks.join("\n\n")
    end

    # assume it's indented code, discard non-indented lines and outdent
    # the rest
    block = block.outdent if block.indented?

    block
  end

  def outdent
    lines = split(/\n/)

    incode = false
    code = []
    lines.each do |line|
      next if line =~ /^\s*$/ && !incode

      incode = true
      code.push(line)
    end

    return self unless code[0]

    indent = code[0].match(/^( {4,}|\t+)(?=\S)/)

    if indent
      code.map! { |line| line.sub(/(?mi)^#{indent[1]}/, '') }.join("\n")
    else
      self
    end
  end

  # Returns an array of snippets. Single snippets are returned without a
  # title, multiple snippets get titles from header lines
  def snippets
    content = dup.remove_meta
    # If there's only one snippet, just clean it and return
    # return [{ 'title' => '', 'code' => content.clean_code.strip }] unless multiple?

    # Split content by ATX headers. Everything on the line after the #
    # becomes the title, code is gleaned from text between that and the
    # next ATX header (or end)
    sections = []
    counter = 0
    code_blocks = {}

    sans_blocks = content.gsub(/^(`{3,})(\w+)?\s*\n(.*?)\n\1/m) do
      counter += 1
      code_blocks["block#{counter}"] = Regexp.last_match(3)
      "<block#{counter}>\n"
    end

    sans_blocks = sans_blocks.gsub(/(?mi)^((?:\s{4,}|\t+)\S[\S\s]*?)(?=\n\S|\Z)/) do
      counter += 1
      code = Regexp.last_match(1).split(/\n/)

      code_blocks["block#{counter}"] = code.join("\n").outdent

      "<block#{counter}>\n"
    end

    content = []
    if sans_blocks =~ /<block\d+>/
      sans_blocks.each_line do |line|
        if line =~ /^#/ || line =~ /<block\d+>/
          content << line
        end
      end

      parts = content.join("\n").split(/^#+/)
    else
      parts = sans_blocks.gsub(/\n{2,}/, "\n\n").split(/^#+/)
    end

    parts.shift if parts.count > 1

    parts.each do |p|
      lines = p.split(/\n/)

      title = lines.count > 1 ? lines.shift.strip.sub(/[.:]$/, '') : 'Default snippet'
      block = lines.join("\n").gsub(/<(block\d+)>/) { code_blocks[Regexp.last_match(1)] }

      code = block.clean_code

      next unless code && !code.empty?

      sections << {
        'title' => title,
        'code' => code
      }
    end
    return sections
  end
end

def find_query_in_options(filename, res, query)
  options = res.map { |m| "#{filename} #{m['title']}" }
  words = query.split(/ +/)
  words.delete_if { |word| options.none? { |o| o =~ /#{word}/i } }
  words.map { |w| w.downcase }.join(' ')
end

def remove_items_without_query(filename, res, query)
  q = find_query_in_options(filename, res, query).split(/ /)
  res.delete_if do |opt|
    !q.any? do |word|
      "#{filename} #{opt['title']}" =~ /#{word}/i
    end
  end
  res
end

def gum_menu(executable, res, title, query, filename)
  unless query.nil? || query.empty?
    res = remove_items_without_query(filename, res, query)
    return res[0] if res.count == 1
  end

  if res.count == 0
    warn 'No matches found'
    Process.exit 1
  end

  options = res.map { |m| m['title'] }
  q = query.nil? ? '' : find_query_in_options(filename, res, query)
  puts title
  selection = `echo #{Shellwords.escape(options.join("\n"))} | #{executable} filter --height=#{options.count}`.strip
  Process.exit 1 if selection.empty?

  res.select { |m| m['title'] =~ /#{Regexp.escape(selection)}/ }[0]
end

def fzf_menu(executable, res, title, query, filename)
  orig_options = res.dup
  unless query.nil? || query.empty?
    res = remove_items_without_query(filename, res, query)
    return res[0] if res.count == 1
  end

  if res.count == 0
    res = orig_options
  end

  options = res.map { |m| "#{filename}: #{m['title']}" }
  q = query.nil? ? '' : find_query_in_options(filename, res, query)
  args = [
    "--height=#{options.count + 2}",
    %(--prompt="#{title} > "),
    '-1',
    %(--header="#{filename}"),
    # '--header-first',
    '--reverse',
    '--no-info',
    %(--query="#{q}"),
    '--tac'
  ]
  selection = `echo #{Shellwords.escape(options.join("\n"))} | #{executable} #{args.join(' ')}`.strip
  Process.exit 1 if selection.empty?

  result = res.select { |m|
    m['title'] == selection.sub(/^.*?: /, '')
  }

  result[0]
end

# Generate a numbered menu, items passed must have a title property
def console_menu(res, title, filename, query: nil)
  unless query.nil? || query.empty?
    res = remove_items_without_query(filename, res, query)
    return res[0] if res.count == 1
  end

  if res.count == 0
    warn 'No matches found'
    Process.exit 1
  end

  stty_save = `stty -g`.chomp

  trap('INT') do
    system('stty', stty_save)
    Process.exit 1
  end

  # Generate a numbered menu, items passed must have a title property('INT') { system('stty', stty_save); exit }
  counter = 1
  $stderr.puts
  res.each do |m|
    $stderr.printf("%<counter>2d) %<title>s\n", counter: counter, title: m['title'])
    counter += 1
  end
  $stderr.puts

  begin
    $stderr.printf(title.sub(/:?$/, ': '), res.length)
    while (line = Readline.readline('', true))
      unless line =~ /^[0-9]/
        system('stty', stty_save) # Restore
        exit
      end
      line = line.to_i
      return res[line - 1] if line.positive? && line <= res.length

      warn 'Out of range'
      console_menu(res, title)
    end
  rescue Interrupt
    system('stty', stty_save)
    exit
  end
end

def menu(res, filename: nil, title: 'Select one', query: nil, options: {})
  query.remove_spotlight_tags! unless query.nil?
  fzf = TTY::Which.which('fzf')
  return fzf_menu(fzf, res, title, query, filename) unless fzf.empty?

  gum = TTY::Which.which('gum')
  return gum_menu(gum, res, title, query, filename) unless gum.empty?

  console_menu(res, title, filename, query: query)
end

# Search the snippets directory for query using find and grep
def search(query, folder, matches: [], try: 0, options: {})
  # start by doing a spotlight search, if that fails, start trying:
  # First try only search by filenames
  # Second try search with grep
  ext = options[:extension] || 'md'
  cmd = case try
        when 1
          %(find "#{folder}" -iregex '#{query.rx}' -name '*.#{ext}')
        when 2
          rg = TTY::Which.which('rg')
          ag = TTY::Which.which('ag')
          ack = TTY::Which.which('ack')
          if options[:name_only]
            nil
          elsif !rg.empty?
            %(#{rg} -li --color=never --glob='*.#{ext}' '#{query.rx}' "#{folder}")
          elsif !ag.empty?
            %(#{ag} -li --nocolor -G '.*.#{ext}' '#{query.rx}' "#{folder}")
          elsif !ack.empty?
            %(#{ack} -li --nocolor --markdown '#{query.rx}' "#{folder}")
          else
            %(grep -iEl '#{query.rx}' "#{folder}"/**/*.#{ext})
          end
        else
          mdfind = TTY::Which.which('mdfind')
          if mdfind.empty?
            nil
          else
            name_only = options[:name_only] ? '-name ' : ''
            %(mdfind -onlyin #{folder} #{name_only}'#{query} filename:.#{ext}' 2>/dev/null)
          end
        end

  res = cmd.nil? ? '' : `#{cmd}`.strip

  results = []

  unless res.empty?
    lines = res.split(/\n/)
    lines.each do |l|
      results << {
        'title' => File.basename(l, '.*'),
        'path' => l
      }
    end

    matches.concat(results).sort_by! { |a| a['title'] }.uniq!

    return matches unless matches.empty?
  end

  return matches if try == 2

  # if no results on the first try, try again searching all text
  search(query, folder, matches: matches, try: try + 1, options: options) if matches.empty?
end

def highlight_pygments(executable, code, syntax, theme)
  syntax = syntax.empty? ? '-g' : "-l #{syntax}"
  `echo #{Shellwords.escape(code)} | #{executable} #{syntax}`
end

def highlight_skylight(executable, code, syntax, theme)
  return code if syntax.empty?

  `echo #{Shellwords.escape(code)} | #{executable} --syntax #{syntax}`
end

def highlight(code, filename, theme = 'monokai')
  syntax = syntax_from_extension(filename)

  skylight = TTY::Which.which('skylighting')
  return highlight_skylight(skylight, code, syntax, theme) unless skylight.empty?

  pygments = TTY::Which.which('pygmentize')
  return highlight_pygments(pygments, code, syntax, theme) unless pygments.empty?

  code
end

@lexers = []

def build_lexers
  DATA.read.split(/\n/).each do |line|
    key = line.match(/(?mi)^((, )?[^,]+?)+?(?=\[)/)[0]
    keys = key.split(/,/).map(&:strip)
    value = line.match(/\[(.*?)\]/)[1]
    values = value.split(/,/).map(&:strip)

    @lexers << {
      lexer: keys.shift,
      aliases: keys,
      extensions: values
    }
  end
end

def ext_to_lang(ext)
  matches = @lexers.select { |lex| lex[:extensions].map(&:downcase).include?(ext.downcase) }
  matches.map { |lex| lex[:lexer] }.first
end

def lang_to_ext(lexer)
  matches = @lexers.select { |lex| lex[:lexer] == lexer || lex[:aliases].map(&:downcase).include?(lexer.downcase) }
  matches.map { |lex| lex[:extensions].first }.first
end

def syntax_from_extension(filename)
  ext_to_lang(filename.split(/\./)[1])
end

def best_editor
  if ENV['EDITOR']
    ENV['EDITOR']
  elsif ENV['GIT_EDITOR']
    ENV['GIT_EDITOR']
  else
    return TTY::Which.which('code') if TTY::Which.exist?('code')

    return TTY::Which.which('subl') if TTY::Which.exist?('subl')

    return TTY::Which.which('bbedit') if TTY::Which.exist?('bbedit')

    return TTY::Which.which('nano') if TTY::Which.exist?('nano')

    return TTY::Which.which('vim') if TTY::Which.exist?('vim')

    return 'TextEdit'
  end
end

def open_snippet_in_editor(filepath, options)
  editor = options[:editor] || best_editor

  if editor.nil?
    `open "#{filepath}"`
  elsif editor =~ /^TextEdit/
    `open -a TextEdit "#{filepath}"`
  elsif TTY::Which.bundle_id?(editor)
    `open -b "#{editor}" "#{filepath}"`
  elsif TTY::Which.app?(editor)
    `open -a "#{editor}" "#{filepath}"`
  else
    if TTY::Which.exist?(editor)
      editor = TTY::Which.which(editor)
      system %(#{editor} "#{filepath}") if editor
    end
  end
end

def new_snippet_from_clipboard(options)
  trap('SIGINT') do
    Howzit.console.info "\nCancelled"
    exit!
  end

  build_lexers

  pb = `pbpaste`.outdent

  printf "What does this snippet do? "
  input = $stdin.gets.chomp
  title = input unless input.empty?

  printf 'What language(s) is it in (separate with spaces)? '
  input = $stdin.gets.chomp
  langs = input.split(/ +/).map(&:strip) unless input.empty?
  exts = langs.map { |lang| lang_to_ext(lang) }
  tags = langs.map { |lang| ext_to_lang(lang) }.concat(langs).sort.uniq

  filename ="#{title}.#{exts.join('.')}.#{options[:extension]}"

  File.open(File.join(options[:source], filename), 'w') do |f|
    f.puts "tags: #{tags.join(', ')}

```
#{pb}
```"
  end

  puts "New snippet written to #{filename}."
end

def config_dir
  File.expand_path('~/.config/snibbets')
end

def config_file
  File.join(config_dir, 'snibbets.yml')
end

def read_config
  if File.exist?(config_file)
    YAML.load(IO.read(config_file))
  else
    {}
  end
end

def write_config(options)
  raise 'Error creating config directory, file exists' if File.exist?(config_dir) && !File.directory?(config_dir)

  FileUtils.mkdir_p(config_dir) unless File.directory?(config_dir)
  File.open(config_file, 'w') { |f| f.puts(YAML.dump(options)) }
end

DEFAULT_OPTIONS = {
  all: false,
  editor: best_editor,
  extension: 'md',
  highlight: false,
  interactive: true,
  launchbar: false,
  name_only: false,
  output: 'raw',
  source: File.expand_path('~/Dropbox/Snippets')
}.freeze

custom_config = read_config
options = DEFAULT_OPTIONS.merge(custom_config)
write_config(options) unless options.equal?(custom_config)

save_config = false
edit_config = false
edit_snippet = false
paste_snippet = false

optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [options] query"

  opts.on('-a', '--all', 'If a file contains multiple snippets, output all of them (no menu)') do
    options[:all] = true
  end

  opts.on('-e', '--edit', 'Open the selected snippet in your configured editor') do
    edit_snippet = true
  end


  opts.on('-n', '--name-only', 'Only search file names, not content') do
    options[:name_only] = true
  end

  opts.on('-o', '--output FORMAT', 'Output format (json|launchbar|raw)') do |outformat|
    valid = %w[json launchbar lb raw]
    if outformat.downcase =~ /(launchbar|lb)/
      options[:launchbar] = true
      options[:interactive] = false
    elsif valid.include?(outformat.downcase)
      options[:output] = outformat.downcase
    end
  end

  opts.on('-p', '--paste', 'Interactively create a new snippet from clipboard contents (Mac only)') do
    paste_snippet = true
  end

  opts.on('-q', '--quiet', 'Skip menus and display first match') do
    options[:interactive] = false
    options[:launchbar] = false
  end

  opts.on('-s', '--source FOLDER', 'Snippets folder to search') do |folder|
    options[:source] = File.expand_path(folder)
  end

  opts.on('--configure', 'Open the configuration file in your default editor') do
    edit_config = true
  end

  opts.on('--highlight', 'Use pygments or skylighting to syntax highlight (if installed)') do
    options[:highlight] = true
  end

  opts.on('--save', 'Save the current command line options to the YAML configuration') do
    save_config = true
  end

  opts.on('-h', '--help', 'Display this screen') do
    puts optparse
    Process.exit 0
  end

  opts.on('-v', '--version', 'Display version information') do
    puts "Snibbets v#{VERSION}"
    Process.exit 0
  end
end

optparse.parse!

if save_config
  write_config(options)
  puts "Configuration saved to #{config_file}"
end

if edit_config
  write_config(options)
  editor = options[:editor]
  if editor.nil?
    `open "#{config_file}"`
  else
    `#{editor} "#{config_file}"`
  end
  Process.exit 0
end

unless File.directory?(options[:source])
  puts "The Snippets folder doesn't exist, please configure it."
  puts "Run `snibbets --configure` to open the config file for editing."
  Process.exit 1
end

if paste_snippet
  new_snippet_from_clipboard(options)
  Process.exit 0
end

query = ''

if options[:launchbar]
  query = if $stdin.stat.size.positive?
            $stdin.read.force_encoding('utf-8')
          else
            ARGV.join(' ')
          end
elsif ARGV.length
  query = ARGV.join(' ')
end

query = CGI.unescape(query)

if query.strip.empty?
  if save_config
    Process.exit 0
  else
    puts 'No search query'
    puts optparse
    Process.exit 1
  end
end

results = search(query, options[:source], matches: [], try: 0, options: options)

if options[:launchbar]
  output = []

  if results.empty?
    out = {
      'title' => 'No matching snippets found'
    }.to_json
    puts out
    Process.exit
  end

  results.each do |result|
    input = IO.read(result['path'])
    snippets = input.snippets
    next if snippets.empty?

    children = []

    if snippets.length == 1
      output << {
        'title' => result['title'],
        'path' => result['path'],
        'action' => 'copyIt',
        'actionArgument' => snippets[0]['code'],
        'label' => 'Copy'
      }
      next
    end

    snippets.each { |s|
      children << {
        'title' => s['title'],
        'path' => result['path'],
        'action' => 'copyIt',
        'actionArgument' => s['code'],
        'label' => 'Copy'
      }
    }

    output << {
      'title' => result['title'],
      'path' => result['path'],
      'children' => children
    }
  end

  puts output.to_json
else
  filepath = nil
  if results.empty?
    warn 'No results'
    Process.exit 0
  elsif results.length == 1 || !options[:interactive]
    filepath = results[0]['path']
    input = IO.read(filepath)
  else
    answer = menu(results, title: 'Select a file', options: options)
    filepath = answer['path']
    input = IO.read(filepath)
  end

  if edit_snippet
    open_snippet_in_editor(filepath, options)
    Process.exit 0
  end

  snippets = input.snippets

  if snippets.empty?
    warn 'No snippets found'
    Process.exit 0
  elsif snippets.length == 1 || !options[:interactive]
    if options[:output] == 'json'
      $stdout.puts snippets.to_json
    else
      snippets.each do |snip|
        header = File.basename(filepath, '.md')
        warn header
        warn '-' * header.length
        code = snip['code']
        code = highlight(code, filepath) if options[:highlight]
        $stdout.puts code
      end
    end
  elsif snippets.length > 1
    if options[:all]
      if options[:output] == 'json'
        $stdout.puts snippets.to_json
      else
        snippets.each do |snippet|
          $stdout.puts snippet['title']
          $stdout.puts '-' * snippet['title'].length
          $stdout.puts snippet['code']
          $stdout.puts
        end
      end
    else
      snippets.push({ 'title' => 'All snippets', 'code' => '' })

      answer = menu(snippets, filename: File.basename(filepath, '.md'), title: 'Select snippet', query: query, options: options)

      if answer['title'] == 'All snippets'
        snippets.delete_if { |s| s['title'] == 'All snippets'}
        if options[:output] == 'json'
          $stdout.puts snippets.to_json
        else
          header = File.basename(filepath, '.md')
          warn header
          warn '=' * header.length
          snippets.each do |snippet|
            $stdout.puts snippet['title']
            $stdout.puts '-' * snippet['title'].length
            $stdout.puts snippet['code']
            $stdout.puts
          end
        end
      elsif options[:output] == 'json'
        $stdout.puts answer.to_json
      else
        header = "#{File.basename(filepath, '.md')}: #{answer['title']}"
        warn header
        warn '-' * header.length
        code = answer['code']
        code = highlight(code, filepath) if options[:highlight]
        $stdout.puts code
      end
    end
  end
end

__END__
abap [abap, ABAP]
abnf [abnf]
actionscript, as [as]
ada [adb, ads, ada]
adl [adl, adls, adlf, adlx]
agda [agda]
aheui [aheui]
alloy [als]
ambienttalk [at]
amdgpu [isa]
ampl [run]
ansys [ans]
apache [.htaccess, apache.conf, apache2.conf]
apl [apl, aplf, aplo, apln, aplc, apli, dyalog]
applescript [applescript]
arduino [ino]
arrow [arw]
asc [asc]
pem [pem, id_dsa, id_ecdsa, id_ecdsa_sk, id_ed25519, id_ed25519_sk, id_rsa]
aspectj [aj]
aspx-vb [aspx, asax, ascx, ashx, asmx, axd]
asymptote, asy [asy]
augeas [aug]
autohotkey, ahk [ahk, ahkl]
autoit [au3]
awk [awk]
bare [bare]
shell [sh, ksh, bash, zsh]
batch [bat, cmd]
bbcbasic [bbc]
bc [bc]
befunge [befunge]
bibtex [bib]
blitzbasic [bb, decls]
blitzmax [bmx]
bnf [bnf]
boa [boa]
boo [boo]
boogie [bpl]
brainfuck, bf [bf, b]
bst [bst]
c-objdump [c-objdump]
c [c, h, idc]
ca65 [s]
cadl [cadl]
cddl [cddl]
ceylon [ceylon]
cfc [cfc]
cf3 [cf]
cfm [cfm, cfml]
chaiscript, chai [chai]
chapel, chpl [chpl]
charmci [ci]
cheetah, spitfire [tmpl, spt]
cirru [cirru]
clay [clay]
clean [icl, dcl]
clojure, clj [clj]
clojurescript, cljs [cljs]
cmake [cmake, CMakeLists.txt]
cobol [cob, cpy]
cobolfree [cbl]
coffeescript, coffee-script, coffee [coffee]
common-lisp, cl [cl]
lisp [lisp]
componentpascal, cp [cp, cps]
coq [v]
cpp, c++ [cpp, hpp, c++, h++, cc, hh, cxx, hxx, C, H, cp, CPP]
cpp-objdump, c++-objdumb, cxx-objdump [cpp-objdump, c++-objdump, cxx-objdump]
cpsa [cpsa]
cr, crystal [cr]
crmsh, pcmk [crmsh, pcmk]
croc [croc]
cryptol, cry [cry]
csharp, c# [cs]
csound, csound-orc [orc, udo]
csound-document, csound-csd [csd]
csound-score, csound-sco [sco]
css [css]
cuda, cu [cu, cuh]
cypher [cyp, cypher]
cython, pyx, pyrex [pyx, pxd, pxi]
d [d, di]
dart [dart]
dasm16 [dasm16, dasm]
delphi, pas, pascal, objectpascal [pas, dpr]
devicetree, dts [dts, dtsi]
dg [dg]
diff, udiff [diff, patch]
docker, dockerfile [Dockerfile, docker]
dpatch [dpatch, darcspatch]
dtd [dtd]
jbst [duel, jbst]
dylan-console, dylan-repl [dylan-console]
dylan-lid, lid [lid, hdp]
dylan [dylan, dyl, intr]
earl-grey, earlgrey, eg [eg]
easytrieve [ezt, mac]
ebnf [ebnf]
ec [ec, eh]
ecl [ecl]
eiffel [e]
elixir, ex, exs [ex, eex, exs, leex]
elm [elm]
emacs-lisp, elisp, emacs [el]
email, eml [eml]
erb [erb]
erl [erl-sh]
erlang [erl, hrl, es, escript]
evoque [evoque]
execline [exec]
extempore [xtm]
ezhil [n]
factor [factor]
fan [fan]
fancy, fy [fy, fancypack]
felix, flx [flx, flxh]
fennel, fnl [fnl]
fish, fishshell [fish, load]
floscript, flo [flo]
forth [frt, fs]
fortran [f03, f90, F03, F90]
fortranfixed [f, F]
foxpro, vfp, clipper, xbase [PRG, prg]
freefem [edp]
fsharp, f# [fs, fsi]
fstar [fst, fsti]
futhark [fut]
gap [g, gd, gi, gap]
gas, asm [s, S]
gcode [gcode]
gdscript, gd [gd]
genshi, kid, xml+genshi, xml+kid [kid]
gherkin, cucumber [feature]
glsl [vert, frag, geo]
gnuplot [plot, plt]
go, golang [go]
golo [golo]
gooddata-cl [gdc]
gosu [gs, gsx, gsp, vark]
graphviz, dot [gv, dot]
groff, nroff, man [man]
groovy [groovy, gradle]
gsql [gsql]
gst [gst]
haml [haml]
haskell, hs [hs]
haxe, hxsl, hx [hx, hxsl]
haxeml, hxml [hxml]
hlsl [hlsl, hlsli]
hsail, hsa [hsail]
handlebars [handlebars, hbs]
html+ng2 [ng2]
html+php [phtml]
html+twig [twig]
html [html, htm, xhtml, xslt]
hybris, hy [hy, hyb]
hylang [hy]
i6t [i6t]
idl [pro]
idris, idr [idr]
igor, igorpro [ipf]
inform6, i6 [inf]
inform7, i7 [ni, i7x]
ini, cfg, dosini [ini, cfg, inf, service, socket, device, mount, automount, swap, target, path, timer, slice, scope]
io [io]
ioke, ik [ik]
isabelle [thy]
j [ijs]
jags [jag, bug]
jasmin, jasminxt [j]
java [java]
javascript, js [js, jsm, mjs, cjs]
jcl [jcl]
jsgf [jsgf]
jslt [jslt]
json, json-object [json]
jsonld, json-ld [jsonld]
jsp [jsp]
julia, jl [jl]
juttle [juttle]
kal [kal]
kmsg, dmesg [kmsg, dmesg]
koka [kk, kki]
kotlin [kt, kts]
kuin [kn]
lasso, lassoscript [lasso]
lean [lean]
less [less]
limbo [b]
liquid [liquid]
literate-agda, lagda [lagda]
literate-cryptol, lcryptol, lcry [lcry]
literate-haskell, lhaskell, lhs [lhs]
literate-idris, lidris, lidr [lidr]
livescript, live-script [ls]
llvm-mir [mir]
llvm [ll]
logos [x, xi, xm, xmi]
logtalk [lgt, logtalk]
lsl [lsl]
lua [lua, wlua]
make, makefile, mf, bsdmake [mak, mk, Makefile, makefile, Makefile. GNUmakefile]
mako [mao]
maql [maql]
markdown, md [md, markdown, mmd]
mask [mask]
mason [m, mhtml, mc, mi, autohandler, dhandler]
mathematica, mma, nb [nb, cdf, nbp, ma]
miniscript, ms [ms]
modelica [mo]
modula2, m2 [def, mod]
monkey [monkey]
monte [mt]
moocode, moo [moo]
moonscript, moon [moon]
mosel [mos]
mscgen, msc [msc]
mupad [mu]
mxml [mxml]
myghty [myt, autodelegate]
ncl [ncl]
nemerle [n]
nesc [nc]
nestedtext, nt [nt]
newlisp [lsp, nl, kif]
newspeak [ns2]
nimrod, nim [nim, nimrod]
nit [nit]
nixos, nix [nix]
nsis, nsi, nsh [nsi, nsh]
nusmv [smv]
objdump [objdump]
objective-c++, objectivec++, obj-c++, objc++ [mm, hh]
objective-c, objectivec, obj-c, objc [m, h]
objective-j, objectivej, obj-j, objj [j]
ocaml [ml, mli, mll, mly]
odin [odin]
omg-idl [idl, pidl]
ooc [ooc]
opa [opa]
openedge, abl, progress [p, cls]
pacmanconf [pacman.conf]
pan [pan]
parasail [psi, psl]
pawn [p, pwn, inc]
peg [peg]
perl, pl [pl, pm, t, perl]
php [php, inc]
pig [pig]
pike [pike, pmod]
pkgconfig [pc]
pointless [ptls]
pony [pony]
postscript, postscr [ps, eps]
pot, po [pot, po]
pov [pov, inc]
powershell, pwsh, posh, ps1, psm1 [ps1, psm1]
praat [praat, proc, psc]
prolog [ecl, prolog, pro, pl]
promql [promql]
properties, jproperties [properties]
protobuf, proto [proto]
pug [pug]
jade [jade]
puppet [pp]
py2tb [py2tb]
pypylog, pypy [pypylog]
pytb, py3tb [pytb, py3tb]
python, py, sage [py, pyw, jy, sage, sc, bzl, tac]
qbasic, basic [BAS, bas]
qml, qbs [qml, qbs]
qvto, qvt [qvto]
racket, rkt [rkt, rktd, rktl]
reasonml, reason [re, rei]
rebol [r, r3, reb]
red [red, reds]
redcode [cw]
registry [reg]
restructuredtext, rst, rest [rst, rest]
rexx, arexx [rexx, rex, rx, arexx]
rhtml [rhtml]
ride [ride]
rng-compact, rnc [rnc]
roboconf-graph [graph]
roboconf-instances [instances]
robotframework [robot]
rql [rql]
rsl [rsl]
ruby, rb [rb, rbw, rake, gemspec, rbx, duby]
rust, rs [rs, rs.in]
sarl [sarl]
sas [SAS, sas]
sass [sass, scss]
scala [scala]
scaml [scaml]
scdoc, scd [scd, scdoc]
scheme, scm [scm, ss]
scilab [sci, sce, tst]
sgf [sgf]
shen [shen]
shexc, shex [shex]
sieve [siv, sieve]
silver [sil, vpr]
slash [sla]
slim [slim]
slurm, sbatch [sl]
smali [smali]
smalltalk, squeak, st [st]
smarty [tpl]
smithy [smithy]
sml [sml, sig, fun]
snobol [snobol]
snowball [sbl]
solidity [sol]
sp [sp]
sparql [rq, sparql]
spec [spec]
r [R]
sql [sql]
ssp [ssp]
stan [stan]
stata, do [do, ado]
supercollider, sc [sc, scd]
swift [swift]
swig [swg, i]
systemverilog, sv [sv, svh]
tads3 [t]
tap [tap]
tasm [tasm]
tcl [tcl, rvt]
tcsh, csh [tcsh, csh]
tea [tea]
teal [teal]
teratermmacro, teraterm, ttl [ttl]
termcap [termcap, termcap.src]
terminfo [terminfo, terminfo.src]
terraform, tf [tf]
tex, latex [tex, aux, toc]
text [txt]
thrift [thrift]
ti, thingsdb [ti]
tid [tid]
tnt [tnt]
trafficscript, rts [rts]
treetop [treetop, tt]
turtle [ttl]
typescript, ts [ts]
typoscript [typoscript]
ucode [u, u1, u2]
urbiscript [u]
usd, usda [usd, usda]
vala, vapi [vala, vapi]
vb.net, vbnet [vb, bas]
vbscript [vbs, VBS]
vcl [vcl]
velocity [vm, fhtml]
verilog, v [v]
vgl [rpf]
vhdl [vhdl, vhd]
vim [vim, .vimrc, .exrc, .gvimrc, _vimrc, _exrc, _gvimrc, vimrc, gvimrc]
wast, wat [wat, wast]
wdiff [wdiff]
webidl [webidl]
whiley [whiley]
x10, xten [x10]
xml [xml, xsl, rss, xslt, xsd, wsdl, wsf]
xquery, xqy, xq, xql, xqm [xqy, xquery, xq, xql, xqm]
xslt [xsl, xslt, xpl]
xtend [xtend]
yaml+jinja, salt, sls [sls]
yaml [yaml, yml]
yang [yang]
zeek [zeek]
bro [bro]
zephir [zep]
zig [zig]
